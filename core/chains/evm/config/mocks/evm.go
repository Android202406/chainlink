// Code generated by mockery v2.35.4. DO NOT EDIT.

package mocks

import (
	big "math/big"

	assets "github.com/smartcontractkit/chainlink/v2/core/assets"

	config "github.com/smartcontractkit/chainlink/v2/core/chains/evm/config"

	coreconfig "github.com/smartcontractkit/chainlink/v2/core/config"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// EVM is an autogenerated mock type for the EVM type
type EVM struct {
	mock.Mock
}

// AutoCreateKey provides a mock function with given fields:
func (_m *EVM) AutoCreateKey() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BalanceMonitor provides a mock function with given fields:
func (_m *EVM) BalanceMonitor() config.BalanceMonitor {
	ret := _m.Called()

	var r0 config.BalanceMonitor
	if rf, ok := ret.Get(0).(func() config.BalanceMonitor); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.BalanceMonitor)
		}
	}

	return r0
}

// BlockBackfillDepth provides a mock function with given fields:
func (_m *EVM) BlockBackfillDepth() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// BlockBackfillSkip provides a mock function with given fields:
func (_m *EVM) BlockBackfillSkip() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlockEmissionIdleWarningThreshold provides a mock function with given fields:
func (_m *EVM) BlockEmissionIdleWarningThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// ChainID provides a mock function with given fields:
func (_m *EVM) ChainID() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// ChainType provides a mock function with given fields:
func (_m *EVM) ChainType() coreconfig.ChainType {
	ret := _m.Called()

	var r0 coreconfig.ChainType
	if rf, ok := ret.Get(0).(func() coreconfig.ChainType); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(coreconfig.ChainType)
	}

	return r0
}

// FinalityDepth provides a mock function with given fields:
func (_m *EVM) FinalityDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// FinalityTagEnabled provides a mock function with given fields:
func (_m *EVM) FinalityTagEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FlagsContractAddress provides a mock function with given fields:
func (_m *EVM) FlagsContractAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GasEstimator provides a mock function with given fields:
func (_m *EVM) GasEstimator() config.GasEstimator {
	ret := _m.Called()

	var r0 config.GasEstimator
	if rf, ok := ret.Get(0).(func() config.GasEstimator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.GasEstimator)
		}
	}

	return r0
}

// HeadTracker provides a mock function with given fields:
func (_m *EVM) HeadTracker() config.HeadTracker {
	ret := _m.Called()

	var r0 config.HeadTracker
	if rf, ok := ret.Get(0).(func() config.HeadTracker); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.HeadTracker)
		}
	}

	return r0
}

// IsEnabled provides a mock function with given fields:
func (_m *EVM) IsEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LinkContractAddress provides a mock function with given fields:
func (_m *EVM) LinkContractAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// LogBackfillBatchSize provides a mock function with given fields:
func (_m *EVM) LogBackfillBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// LogKeepBlocksDepth provides a mock function with given fields:
func (_m *EVM) LogKeepBlocksDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// LogPollInterval provides a mock function with given fields:
func (_m *EVM) LogPollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// MinContractPayment provides a mock function with given fields:
func (_m *EVM) MinContractPayment() *assets.Link {
	ret := _m.Called()

	var r0 *assets.Link
	if rf, ok := ret.Get(0).(func() *assets.Link); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Link)
		}
	}

	return r0
}

// MinIncomingConfirmations provides a mock function with given fields:
func (_m *EVM) MinIncomingConfirmations() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// NodeNoNewHeadsThreshold provides a mock function with given fields:
func (_m *EVM) NodeNoNewHeadsThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// NodePool provides a mock function with given fields:
func (_m *EVM) NodePool() config.NodePool {
	ret := _m.Called()

	var r0 config.NodePool
	if rf, ok := ret.Get(0).(func() config.NodePool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.NodePool)
		}
	}

	return r0
}

// NonceAutoSync provides a mock function with given fields:
func (_m *EVM) NonceAutoSync() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCR provides a mock function with given fields:
func (_m *EVM) OCR() config.OCR {
	ret := _m.Called()

	var r0 config.OCR
	if rf, ok := ret.Get(0).(func() config.OCR); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.OCR)
		}
	}

	return r0
}

// OCR2 provides a mock function with given fields:
func (_m *EVM) OCR2() config.OCR2 {
	ret := _m.Called()

	var r0 config.OCR2
	if rf, ok := ret.Get(0).(func() config.OCR2); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.OCR2)
		}
	}

	return r0
}

// OperatorFactoryAddress provides a mock function with given fields:
func (_m *EVM) OperatorFactoryAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// RPCDefaultBatchSize provides a mock function with given fields:
func (_m *EVM) RPCDefaultBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// TOMLString provides a mock function with given fields:
func (_m *EVM) TOMLString() (string, error) {
	ret := _m.Called()

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transactions provides a mock function with given fields:
func (_m *EVM) Transactions() config.Transactions {
	ret := _m.Called()

	var r0 config.Transactions
	if rf, ok := ret.Get(0).(func() config.Transactions); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.Transactions)
		}
	}

	return r0
}

// NewEVM creates a new instance of EVM. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEVM(t interface {
	mock.TestingT
	Cleanup(func())
}) *EVM {
	mock := &EVM{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
